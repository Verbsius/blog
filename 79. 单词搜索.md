# 79. 单词搜索
## QUESTION
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
## SOLUTION
~~~
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int row = board.size(), col = board[0].size();
        auto dfs = [&](this auto && dfs, int i, int j, int k)  {
            if (board[i][j] != word[k]) return false;
            else if (k == word.size() - 1) return true;

            // 当匹配成功时但不是结束时
            // 标记
            board[i][j] = 0;
            
            if ( i + 1 < row) {
                if (dfs(i + 1, j, k + 1)) {
     
                    return true;
                }
            }

            if (i - 1 >= 0) {
                if (dfs(i - 1, j, k + 1)) {

                    return true;
                }
            }

            if ( j + 1 < col) {
                if ( dfs(i, j + 1, k + 1)) {
  
                    return true;
                }
            }

            if (j - 1 >= 0) {
                if (dfs(i , j - 1, k + 1)) {
   
                    return true;
                }
            }

            board[i][j] = word[k];
            
            return false;
            
        };
        
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (dfs(i , j, 0)) return true;
            }
        }

        return false;
    }
};
~~~
## EXPLANATION
枚举 i=0,1,2,…,m−1 和 j=0,1,2,…,n−1，以 (i,j) 为起点开始搜索。

同时，我们还需要知道当前匹配到了 word 的第几个字母，所以还需要一个参数 k。

定义 dfs(i,j,k) 表示当前在 board[i][j] 这个格子，要匹配 word[k]，返回在这个状态下最终能否匹配成功（搜索成功）。

分类讨论：

如果 board[i][j] != word[k]，匹配失败，返回 false。
否则，如果 k=len(word)−1，匹配成功，返回 true。
否则，枚举 (i,j) 周围的四个相邻格子 (x,y)，如果 (x,y) 没有出界，则递归 dfs(x,y,k+1)，如果其返回 true，则 dfs(i,j,k) 也返回 true。
如果递归周围的四个相邻格子都没有返回 true，则最后返回 false，表示没有搜到。

注意要标记已检查过的字母，不然会回头检查。
