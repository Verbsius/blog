# 比较器在sort()和priority_queue()的不同
测试代码如下
~~~
#include <queue>
#include <vector>
#include <algorithm>
#include <iostream>
#include <functional>
using namespace std;



void test01() {
    vector<int> v;
    v.reserve(4);

   int a = 1, b = 2, c = 5, d = 0;
    v.push_back(a); v.push_back(b); v.push_back(c); v.push_back(d);

    sort(v.begin(), v.end(), less<int>()); // 注意 less<int> 的使用

    for (int i = 0; i < v.size(); ++i)
        cout << v[i]<< endl;
}


void test02() {
    priority_queue<int, vector<int>, less<int>> pq;

   int a = 1, b = 2, c = 5, d = 0;
    pq.push(a); 
    pq.push(b); 
    pq.push(c); 
    pq.push(d);

    cout << pq.top() <<endl; pq.pop();
    cout << pq.top() <<endl; pq.pop();
    cout << pq.top() <<endl; pq.pop();
    cout << pq.top() <<endl; pq.pop();


    
}



int main() {
    cout << "less<int> 在sort的使用" << endl;
    test01();
    cout << "less<int> 在pq的使用" << endl;
    test02();
}
~~~

结果如下：
~~~
less<int> 在sort的使用
0
1
2
5
less<int> 在pq的使用
5
2
1
0
~~~
std::less<T> 可能的实现代码
~~~
constexpr bool operator()(const T& lhs, const T& rhs) const 
{
    return lhs < rhs; 
}
~~~
在sort里面使用less，是升序，在pq里面使用，是降序。造成这个现象的原因是因为pq默认使用less<T>是实现最大堆，违背直觉！以下是cppreference原话：
Note that the Compare parameter is defined such that it returns true if its first argument comes before its second argument in a weak ordering. But because the priority queue outputs largest elements first, the elements that "come before" are actually output last. That is, the front of the queue contains the "last" element according to the weak ordering imposed by Compare.
我们只需要反着记忆就可以了。


